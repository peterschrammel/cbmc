/*
 *  generated by CSeq [ 0000 / 0000 ]
 * 
 *  instance version    {}
 *
 *  2019-08-30 14:26:07
 *
 *  params:
 *    -l datarace, --unwind 1, --rounds 1, --debug , --variable-array-size 2, --local-vars 2, --seq , -i ../debian-benchmarks-threads-locks-25k/augeas-1.2.0_gnulib_tests_test-thread_create.c, 
 *
 */
#define __cs_MUTEX_INITIALIZER -1
#define __cs_COND_INITIALIZER -1
#define __cs_RWLOCK_INITIALIZER -1
#define __cs_BARRIER_SERIAL_THREAD 0
#define __cs_CANCEL_ASYNCHRONOUS 0
#define __cs_CANCEL_ENABLE 0
#define __cs_CANCEL_DEFERRED 0
#define __cs_CANCEL_DISABLE 0
#define __cs_CANCELED 0
#define __cs_CREATE_DETACHED 0
#define __cs_CREATE_JOINABLE 0
#define __cs_EXPLICIT_SCHED 0
#define __cs_INHERIT_SCHED 0
#define __cs_MUTEX_DEFAULT 0
#define __cs_MUTEX_ERRORCHECK 0
#define __cs_MUTEX_NORMAL 0
#define __cs_MUTEX_RECURSIVE 0
#define __cs_MUTEX_ROBUST 0
#define __cs_MUTEX_STALLED 0
#define __cs_ONCE_INIT 0
#define __cs_PRIO_INHERIT 0
#define __cs_PRIO_NONE 0
#define __cs_PRIO_PROTECT 0
#define __cs_PROCESS_SHARED 0
#define __cs_PROCESS_PRIVATE 0
#define __cs_SCOPE_PROCESS 0
#define __cs_SCOPE_SYSTEM 0
#include <assert.h>
#include <stdarg.h>
int __VERIFIER_nondet_int();
int nondet_int();
unsigned int __VERIFIER_nondet_uint();
unsigned int nondet_uint();
_Bool __VERIFIER_nondet_bool();
_Bool nondet_bool();
char __VERIFIER_nondet_char();
char nondet_char();
unsigned char __VERIFIER_nondet_uchar();
unsigned char nondet_uchar();
#define THREADS 1
#define ROUNDS 1
#define STOP_VOID(A) return;
#define STOP_NONVOID(A) return 0;
#define IF(T,A,B) if ((__cs_pc[T] > A) | (A >= __cs_pc_cs[T])) goto B; 

                                        unsigned __CPROVER_bitvector[1] __cs_active_thread[2] = {1};
                                        unsigned __CPROVER_bitvector[5] __cs_pc[2];
                                        unsigned __CPROVER_bitvector[6] __cs_pc_cs[2];
                                        unsigned __CPROVER_bitvector[1] __cs_last_thread;
                                        unsigned __CPROVER_bitvector[5] __cs_thread_lines[2] = {17, 1};
                                        void *malloc(unsigned long int);
                                        void *__cs_safe_malloc(unsigned int __cs_size)
                                        {
                                                  void *__cs_ptr = (malloc(__cs_size));
                                                  return __cs_ptr;
                                        }
                                        void __CSEQ_message(char *__cs_message)
                                        {
                                                  ;
                                        }
                                        typedef int __cs_t;
                                        void *__cs_threadargs[2];
                                        void *__cs_thread_joinargs[2];
                                        int __cs_create(__cs_t *__cs_new_thread_id, void *__cs_attr, void *(*__cs_thread_function)(void *), void *__cs_arg, int __cs_threadID)
                                        {
                                                  if (__cs_threadID > THREADS)
                                                            return 0;
                                                  *__cs_new_thread_id = __cs_threadID;
                                                  __cs_active_thread[__cs_threadID] = 1;
                                                  __cs_threadargs[__cs_threadID] = __cs_arg;
                                                  __CSEQ_message("thread spawned");
                                                  return 0;
                                        }
                                        int __cs_join(__cs_t __cs_id, void **__cs_value_ptr)
                                        {
                                                  __CPROVER_assume(__cs_pc[__cs_id] == __cs_thread_lines[__cs_id]);
                                                  *__cs_value_ptr = __cs_thread_joinargs[__cs_id];
                                                  return 0;
                                        }
                                        int __cs_exit(void *__cs_value_ptr, unsigned int __cs_thread_index)
                                        {
                                                  __cs_thread_joinargs[__cs_thread_index] = __cs_value_ptr;
                                                  return 0;
                                        }
                                        int __cs_self(void)
                                        {
                                                  return 1;
                                        }
                                        typedef int __cs_mutex_t;
                                        int __cs_mutex_init(__cs_mutex_t *__cs_m, int __cs_val)
                                        {
                                                  *__cs_m = -1;
                                                  return 0;
                                        }
                                        int __cs_mutex_destroy(__cs_mutex_t *__cs_mutex_to_destroy)
                                        {
                                                  __CPROVER_assume((*__cs_mutex_to_destroy) == (-1));
                                                  *__cs_mutex_to_destroy = -2;
                                                  __CSEQ_message("lock destroyed");
                                                  return 0;
                                        }
                                        int __cs_mutex_lock(__cs_mutex_t *__cs_mutex_to_lock, unsigned __CPROVER_bitvector[1] __cs_thread_index)
                                        {
                                                  __CPROVER_assume((*__cs_mutex_to_lock) == (-1));
                                                  *__cs_mutex_to_lock = __cs_thread_index + 1;
                                                  __CSEQ_message("lock acquired");
                                                  return 0;
                                        }
                                        int __cs_mutex_unlock(__cs_mutex_t *__cs_mutex_to_unlock, unsigned __CPROVER_bitvector[1] __cs_thread_index)
                                        {
                                                  __CPROVER_assume((*__cs_mutex_to_unlock) == (__cs_thread_index + 1));
                                                  *__cs_mutex_to_unlock = -1;
                                                  __CSEQ_message("lock released");
                                                  return 0;
                                        }
                                        typedef int __cs_rwlock_t;
                                        int __cs_rwlock_init(__cs_rwlock_t *__cs_rwlock, int _cs_val)
                                        {
                                                  *__cs_rwlock = -1;
                                                  return 0;
                                        }
                                        int __cs_rwlock_rdlock(__cs_rwlock_t *__cs_rwlock, unsigned int __cs_thread_index)
                                        {
                                                  __CPROVER_assume((*__cs_rwlock) == (-1));
                                                  *__cs_rwlock = __cs_thread_index + 1;
                                                  __CSEQ_message("rwlock read acquired");
                                                  return 0;
                                        }
                                        int __cs_rwlock_unlock(__cs_rwlock_t *__cs_rwlock, unsigned int __cs_thread_index)
                                        {
                                                  __CPROVER_assume((*__cs_rwlock) == (__cs_thread_index + 1));
                                                  *__cs_rwlock = -1;
                                                  __CSEQ_message("lock released");
                                                  return 0;
                                        }
                                        int __cs_rwlock_wrlock(__cs_rwlock_t *__cs_rwlock, unsigned int __cs_thread_index)
                                        {
                                                  __CPROVER_assume((*__cs_rwlock) == (-1));
                                                  *__cs_rwlock = __cs_thread_index + 1;
                                                  __CSEQ_message("rwlock write acquired");
                                                  return 0;
                                        }
                                        int __cs_rwlock_destroy(__cs_rwlock_t *__cs_rwlock)
                                        {
                                                  __CPROVER_assume((*__cs_rwlock) == (-1));
                                                  *__cs_rwlock = -2;
                                                  __CSEQ_message("lock destroyed");
                                                  return 0;
                                        }
                                        typedef int __cs_sem_t;
                                        int __cs_sem_init(__cs_sem_t *sem, int pshared, unsigned int value)
                                        {
                                                  *sem = 2;
                                                  return 0;
                                        }
                                        int __cs_sem_wait(__cs_sem_t *sem)
                                        {
                                                  __CPROVER_assume((*sem) == 2);
                                                  *sem = 1;
                                                  __CSEQ_message("semaphore locked");
                                                  return 0;
                                        }
                                        int __cs_sem_post(__cs_sem_t *sem)
                                        {
                                                  __CPROVER_assume((*sem) == 1);
                                                  *sem = 2;
                                                  __CSEQ_message("semaphore unlocked");
                                                  return 0;
                                        }
                                        int __cs_sem_destroy(__cs_sem_t *sem)
                                        {
                                                  __CPROVER_assume((*sem) == 2);
                                                  *sem = -1;
                                                  __CSEQ_message("semaphore destroyed");
                                                  return 0;
                                        }
                                        typedef int __cs_spinlock_t;
                                        int __cs_spin_init(__cs_spinlock_t *__cs_lock, int _cs_val)
                                        {
                                                  *__cs_lock = -1;
                                                  return 0;
                                        }
                                        int __cs_spin_lock(__cs_spinlock_t *__cs_lock, unsigned int __cs_thread_index)
                                        {
                                                  __CPROVER_assume((*__cs_lock) == (-1));
                                                  *__cs_lock = __cs_thread_index + 1;
                                                  __CSEQ_message("spinlock acquired");
                                                  return 0;
                                        }
                                        int __cs_spin_unlock(__cs_spinlock_t *__cs_lock, unsigned int __cs_thread_index)
                                        {
                                                  __CPROVER_assume((*__cs_lock) == (__cs_thread_index + 1));
                                                  *__cs_lock = -1;
                                                  __CSEQ_message("spinlock released");
                                                  return 0;
                                        }
                                        int __cs_spin_destroy(__cs_spinlock_t *__cs_lock)
                                        {
                                                  __CPROVER_assume((*__cs_lock) == (-1));
                                                  *__cs_lock = -2;
                                                  __CSEQ_message("lock destroyed");
                                                  return 0;
                                        }
                                        typedef int __cs_cond_t;
                                        int __cs_cond_init(__cs_cond_t *__cs_cond_to_init, void *__cs_attr)
                                        {
                                                  *__cs_cond_to_init = -1;
                                                  return 0;
                                        }
                                        int __cs_cond_destroy(__cs_cond_t *__cs_cond_to_destroy)
                                        {
                                                  *__cs_cond_to_destroy = -2;
                                                  return 0;
                                        }
                                        int __cs_cond_wait_1(__cs_cond_t *__cs_cond_to_wait_for, __cs_mutex_t *__cs_m, unsigned int __cs_thread_index)
                                        {
                                                  __CPROVER_assume((*__cs_cond_to_wait_for) != 0);
                                                  __CPROVER_assume((*__cs_cond_to_wait_for) != (-2));
                                                  __cs_mutex_unlock(__cs_m, __cs_thread_index);
                                                  return 0;
                                        }
                                        int __cs_cond_wait_2(__cs_cond_t *__cs_cond_to_wait_for, __cs_mutex_t *__cs_m, unsigned int __cs_thread_index)
                                        {
                                                  __CPROVER_assume((*__cs_cond_to_wait_for) == 1);
                                                  __cs_mutex_lock(__cs_m, __cs_thread_index);
                                                  return 0;
                                        }
                                        int __cs_cond_signal(__cs_cond_t *__cs_cond_to_signal)
                                        {
                                                  *__cs_cond_to_signal = 1;
                                                  __CSEQ_message("conditional variable signal");
                                                  return 0;
                                        }
                                        int __cs_cond_broadcast(__cs_cond_t *__cs_cond_to_broadcast)
                                        {
                                                  *__cs_cond_to_broadcast = 1;
                                                  __CSEQ_message("conditional variable broadcast");
                                                  return 0;
                                        }
                                        typedef struct __cs_barrier_t
                                        {
                                                  unsigned int init;
                                                  unsigned int current;
                                        } __cs_barrier_t;
                                        int __cs_barrier_init(__cs_barrier_t *__cs_barrier_to_init, void *__cs_attr, unsigned int count)
                                        {
                                                  __CPROVER_assume(count > 0);
                                                  __cs_barrier_to_init->current = count;
                                                  __cs_barrier_to_init->init = count;
                                                  return 0;
                                        }
                                        int __cs_barrier_destroy(__cs_barrier_t *__cs_barrier_to_destroy)
                                        {
                                                  __cs_barrier_to_destroy->init = -1;
                                                  __cs_barrier_to_destroy->current = -1;
                                                  return 0;
                                        }
                                        int __cs_barrier_wait_1(__cs_barrier_t *__cs_barrier_to_wait)
                                        {
                                                  __CPROVER_assume(__cs_barrier_to_wait->init > 0);
                                                  __cs_barrier_to_wait->current--;
                                                  return 0;
                                        }
                                        int __cs_barrier_wait_2(__cs_barrier_t *__cs_barrier_to_wait)
                                        {
                                                  __CPROVER_assume(__cs_barrier_to_wait->init > 0);
                                                  __CPROVER_assume(__cs_barrier_to_wait->current == 0);
                                                  __cs_barrier_to_wait->current = __cs_barrier_to_wait->init;
                                                  return 0;
                                        }
                                        typedef int __cs_attr_t;
                                        struct sched_param
                                        {
                                                  signed int sched_priority;
                                        };
                                        int __cs_attr_init(__cs_attr_t *t)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_destroy(__cs_attr_t *t)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_getdetachstate(const __cs_attr_t *t, int *s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_getguardsize(const __cs_attr_t *t, unsigned int *s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_getinheritsched(const __cs_attr_t *t, int *s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_getschedparam(const __cs_attr_t *t, struct sched_param *s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_getschedpolicy(const __cs_attr_t *t, int *s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_getscope(const __cs_attr_t *t, int *s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_getstackaddr(const __cs_attr_t *t, void **s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_getstacksize(const __cs_attr_t *t, unsigned int *s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_setdetachstate(__cs_attr_t *t, int s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_setguardsize(__cs_attr_t *t, unsigned int s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_setinheritsched(__cs_attr_t *t, int s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_setschedparam(__cs_attr_t *t, const struct sched_param *s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_setschedpolicy(__cs_attr_t *t, int s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_setscope(__cs_attr_t *t, int s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_setstackaddr(__cs_attr_t *t, void *s)
                                        {
                                                  return 0;
                                        }
                                        int __cs_attr_setstacksize(__cs_attr_t *t, unsigned int s)
                                        {
                                                  return 0;
                                        }
                                        _Bool __cs_dataraceDetectionStarted = (0);
                                        _Bool __cs_dataraceSecondThread = (0);
                                        _Bool __cs_dataraceNotDetected = (1);
                                        _Bool __cs_dataraceContinue = (1);
                                        enum anonymous$5
                                        {
                                                            TYPE_NONE = 0,
                                                            TYPE_SCHAR = 1,
                                                            TYPE_UCHAR = 2,
                                                            TYPE_SHORT = 3,
                                                            TYPE_USHORT = 4,
                                                            TYPE_INT = 5,
                                                            TYPE_UINT = 6,
                                                            TYPE_LONGINT = 7,
                                                            TYPE_ULONGINT = 8,
                                                            TYPE_LONGLONGINT = 9,
                                                            TYPE_ULONGLONGINT = 10,
                                                            TYPE_DOUBLE = 11,
                                                            TYPE_LONGDOUBLE = 12,
                                                            TYPE_CHAR = 13,
                                                            TYPE_WIDE_CHAR = 14,
                                                            TYPE_STRING = 15,
                                                            TYPE_WIDE_STRING = 16,
                                                            TYPE_POINTER = 17,
                                                            TYPE_COUNT_SCHAR_POINTER = 18,
                                                            TYPE_COUNT_SHORT_POINTER = 19,
                                                            TYPE_COUNT_INT_POINTER = 20,
                                                            TYPE_COUNT_LONGINT_POINTER = 21,
                                                            TYPE_COUNT_LONGLONGINT_POINTER = 22
                                        };
                                        struct anonymous$1;
                                        struct anonymous$3;
                                        struct anonymous;
                                        struct anonymous$2;
                                        union anonymous$0;
                                        union anonymous$4;
                                        union anonymous$6;
                                        struct _IO_FILE;
                                        struct _IO_marker;
                                        struct __locale_data;
                                        struct __locale_struct;
                                        struct __pthread_internal_list;
                                        struct __pthread_mutex_s;
                                        struct hash_node;
                                        struct header;
                                        struct preliminary_header;
                                        union pthread_attr_t;
                                        struct stat;
                                        struct timespec;
                                        struct timeval;
                                        struct timezone;
                                        void __assert_fail(const char *, const char *, unsigned int, const char *);
                                        signed int *__errno_location(void);
                                        void abort(void);
                                        char *asnprintf(char *__cs_param__resultbuf, unsigned long int *__cs_param__lengthp, const char *__cs_param__format, ...);
                                        _Bool c_isalnum(signed int __cs_param__c);
                                        _Bool c_isalpha(signed int __cs_param__c);
                                        _Bool c_isascii(signed int __cs_param__c);
                                        _Bool c_isblank(signed int __cs_param__c);
                                        _Bool c_iscntrl(signed int __cs_param__c);
                                        _Bool c_isdigit(signed int __cs_param__c);
                                        _Bool c_isgraph(signed int __cs_param__c);
                                        _Bool c_islower(signed int __cs_param__c);
                                        _Bool c_isprint(signed int __cs_param__c);
                                        _Bool c_ispunct(signed int __cs_param__c);
                                        _Bool c_isspace(signed int __cs_param__c);
                                        _Bool c_isupper(signed int __cs_param__c);
                                        _Bool c_isxdigit(signed int __cs_param__c);
                                        signed int c_strcasecmp(const char *__cs_param__s1, const char *__cs_param__s2);
                                        signed int c_strncasecmp(const char *__cs_param__s1, const char *__cs_param__s2, unsigned long int __cs_param__n);
                                        signed int c_tolower(signed int __cs_param__c);
                                        signed int c_toupper(signed int __cs_param__c);
                                        void *calloc(unsigned long int, unsigned long int);
                                        signed int close(signed int);
                                        signed int fclose(struct _IO_FILE *);
                                        struct _IO_FILE *fdopen(signed int, const char *);
                                        signed int fflush(struct _IO_FILE *);
                                        signed int fgetfilecon(signed int, char **);
                                        signed int fprintf(struct _IO_FILE *, const char *, ...);
                                        signed int fputs(const char *, struct _IO_FILE *);
                                        void free(void *);
                                        void freea(void *__cs_param__p);
                                        void freecon(char *);
                                        signed int fscanf(struct _IO_FILE *, const char *, ...);
                                        signed int gen_tempname(char *__cs_param__tmpl, signed int __cs_param__suffixlen, signed int __cs_param__flags, signed int __cs_param__kind);
                                        static const char *get_charset_aliases(void);
                                        signed int getc_unlocked(struct _IO_FILE *);
                                        char *getenv(const char *);
                                        signed int getfilecon(const char *, char **);
                                        signed int getpid(void);
                                        signed int gettimeofday(struct timeval *, struct timezone *);
                                        const char *gl_locale_name(signed int __cs_param__category, const char *__cs_param__categoryname);
                                        const char *gl_locale_name_default(void);
                                        const char *gl_locale_name_environ(signed int __cs_param__category, const char *__cs_param__categoryname);
                                        const char *gl_locale_name_posix(signed int __cs_param__category, const char *__cs_param__categoryname);
                                        const char *gl_locale_name_thread(signed int __cs_param__category, const char *__cs_param__categoryname);
                                        static const char *gl_locale_name_thread_unsafe(signed int __cs_param__category, const char *__cs_param__categoryname);
                                        static const char *gl_locale_name_thread_unsafe$link1(signed int __cs_param__category$link1, const char *__cs_param__categoryname$link1);
                                        signed int glthread_once_singlethreaded(signed int *__cs_param__once_control);
                                        signed int glthread_recursive_lock_init_multithreaded(union anonymous$6 *__cs_param__lock);
                                        signed int lgetfilecon(const char *, char **);
                                        const char *locale_charset(void);
                                        signed int lstat(const char *, struct stat *);
                                        static signed int map_to_failure(signed int __cs_param__ret, char **__cs_param__con);
                                        void *memchr(const void *, signed int, unsigned long int);
                                        signed int memcmp(const void *, const void *, unsigned long int);
                                        void *memcpy(void *, const void *, unsigned long int);
                                        signed int mkdir(const char *, unsigned int);
                                        void *mmalloca(unsigned long int __cs_param__n);
                                        char *nl_langinfo(signed int);
                                        signed int open(const char *, signed int, ...);
                                        signed int printf_fetchargs(__builtin_va_list __cs_param__args, struct anonymous$2 *__cs_param__a);
                                        signed int printf_parse(const char *__cs_param__format, struct anonymous *__cs_param__d, struct anonymous$2 *__cs_param__a);
                                        signed int pthread_cancel(unsigned long int);
                                        signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void *(*)(void *), void *);
                                        signed int pthread_join(unsigned long int, void **);
                                        signed int pthread_mutex_init(union anonymous$6 *, const union anonymous$0 *);
                                        signed int pthread_mutex_lock(union anonymous$6 *);
                                        signed int pthread_mutex_unlock(union anonymous$6 *);
                                        signed int pthread_mutexattr_destroy(union anonymous$0 *);
                                        signed int pthread_mutexattr_init(union anonymous$0 *);
                                        signed int pthread_mutexattr_settype(union anonymous$0 *, signed int);
                                        unsigned long int pthread_self(void);
                                        void *realloc(void *, unsigned long int);
                                        signed int rpl_fgetfilecon(signed int __cs_param__fd, char **__cs_param__con);
                                        signed int rpl_getfilecon(const char *__cs_param__file, char **__cs_param__con);
                                        signed int rpl_lgetfilecon(const char *__cs_param__file, char **__cs_param__con);
                                        signed int safe_alloc_alloc_n(void *__cs_param__ptrptr, unsigned long int __cs_param__size, unsigned long int __cs_param__count, signed int __cs_param__zeroed);
                                        signed int safe_alloc_realloc_n(void *__cs_param__ptrptr, unsigned long int __cs_param__size, unsigned long int __cs_param__count);
                                        char *setlocale(signed int, const char *);
                                        signed int snprintf(char *, unsigned long int, const char *, ...);
                                        signed int strcmp(const char *, const char *);
                                        char *strcpy(char *, const char *);
                                        static unsigned long int string_hash(const void *__cs_param__x);
                                        static unsigned long int string_hash$link1(const void *__cs_param__x$link1);
                                        unsigned long int strlen(const char *);
                                        unsigned long int strnlen1(const char *__cs_param__string, unsigned long int __cs_param__maxlen);
                                        static const char *struniq(const char *__cs_param__string);
                                        static const char *struniq$link1(const char *__cs_param__string$link1);
                                        signed int ungetc(signed int, struct _IO_FILE *);
                                        struct __locale_struct *uselocale(struct __locale_struct *);
                                        char *vasnprintf(char *__cs_param__resultbuf, unsigned long int *__cs_param__lengthp, const char *__cs_param__format, void **__cs_param__args);
                                        static void *worker_thread_func_0(void *__cs_param__arg);
                                        static unsigned long int xmax(unsigned long int __cs_param__size1, unsigned long int __cs_param__size2);
                                        static unsigned long int xsum(unsigned long int __cs_param__size1, unsigned long int __cs_param__size2);
                                        static unsigned long int xsum$link1(unsigned long int __cs_param__size1$link1, unsigned long int __cs_param__size2$link1);
                                        static unsigned long int xsum4(unsigned long int __cs_param__size1, unsigned long int __cs_param__size2, unsigned long int __cs_param__size3, unsigned long int __cs_param__size4);
                                        struct anonymous$1
                                        {
                                                  const char *dir_start;
                                                  const char *dir_end;
                                                  signed int flags;
                                                  const char *width_start;
                                                  const char *width_end;
                                                  unsigned long int width_arg_index;
                                                  const char *precision_start;
                                                  const char *precision_end;
                                                  unsigned long int precision_arg_index;
                                                  char conversion;
                                                  unsigned long int arg_index;
                                        };
                                        union anonymous$4
                                        {
                                                  signed char a_schar;
                                                  unsigned char a_uchar;
                                                  signed short int a_short;
                                                  unsigned short int a_ushort;
                                                  signed int a_int;
                                                  unsigned int a_uint;
                                                  signed long int a_longint;
                                                  unsigned long int a_ulongint;
                                                  signed long long int a_longlongint;
                                                  unsigned long long int a_ulonglongint;
                                                  float a_float;
                                                  double a_double;
                                                  long double a_longdouble;
                                                  signed int a_char;
                                                  unsigned int a_wide_char;
                                                  const char *a_string;
                                                  const signed int *a_wide_string;
                                                  void *a_pointer;
                                                  signed char *a_count_schar_pointer;
                                                  signed short int *a_count_short_pointer;
                                                  signed int *a_count_int_pointer;
                                                  signed long int *a_count_longint_pointer;
                                                  signed long long int *a_count_longlongint_pointer;
                                        };
                                        struct anonymous$3
                                        {
                                                  enum anonymous$5 type;
                                                  union anonymous$4 a;
                                        };
                                        struct anonymous
                                        {
                                                  unsigned long int count;
                                                  struct anonymous$1 *dir;
                                                  unsigned long int max_width_length;
                                                  unsigned long int max_precision_length;
                                                  struct anonymous$1 direct_alloc_dir[7l];
                                        };
                                        struct anonymous$2
                                        {
                                                  unsigned long int count;
                                                  struct anonymous$3 *arg;
                                                  struct anonymous$3 direct_alloc_arg[7l];
                                        };
                                        union anonymous$0
                                        {
                                                  char __size[4l];
                                                  signed int __align;
                                        };
                                        struct __pthread_internal_list
                                        {
                                                  struct __pthread_internal_list *__prev;
                                                  struct __pthread_internal_list *__next;
                                        };
                                        struct __pthread_mutex_s
                                        {
                                                  signed int __lock;
                                                  unsigned int __count;
                                                  signed int __owner;
                                                  unsigned int __nusers;
                                                  signed int __kind;
                                                  signed short int __spins;
                                                  signed short int __elision;
                                                  struct __pthread_internal_list __list;
                                        };
                                        union anonymous$6
                                        {
                                                  struct __pthread_mutex_s __data;
                                                  char __size[40l];
                                                  signed long int __align;
                                        };
                                        struct _IO_FILE
                                        {
                                                  signed int _flags;
                                                  char *_IO_read_ptr;
                                                  char *_IO_read_end;
                                                  char *_IO_read_base;
                                                  char *_IO_write_base;
                                                  char *_IO_write_ptr;
                                                  char *_IO_write_end;
                                                  char *_IO_buf_base;
                                                  char *_IO_buf_end;
                                                  char *_IO_save_base;
                                                  char *_IO_backup_base;
                                                  char *_IO_save_end;
                                                  struct _IO_marker *_markers;
                                                  struct _IO_FILE *_chain;
                                                  signed int _fileno;
                                                  signed int _flags2;
                                                  signed long int _old_offset;
                                                  unsigned short int _cur_column;
                                                  signed char _vtable_offset;
                                                  char _shortbuf[1l];
                                                  void *_lock;
                                                  signed long int _offset;
                                                  void *__pad1;
                                                  void *__pad2;
                                                  void *__pad3;
                                                  void *__pad4;
                                                  unsigned long int __pad5;
                                                  signed int _mode;
                                                  char _unused2[(signed long int) ((sizeof(signed int)) * 5)];
                                        };
                                        struct _IO_marker
                                        {
                                                  struct _IO_marker *_next;
                                                  struct _IO_FILE *_sbuf;
                                                  signed int _pos;
                                        };
                                        struct __locale_struct
                                        {
                                                  struct __locale_data *__locales[13l];
                                                  const unsigned short int *__ctype_b;
                                                  const signed int *__ctype_tolower;
                                                  const signed int *__ctype_toupper;
                                                  const char *__names[13l];
                                        };
                                        struct hash_node
                                        {
                                                  struct hash_node * volatile next;
                                                  char contents[100l];
                                        };
                                        struct header
                                        {
                                                  void *next;
                                                  char room[4l];
                                        };
                                        struct preliminary_header
                                        {
                                                  void *next;
                                                  char room[(signed long int) (sizeof(signed int))];
                                        };
                                        union pthread_attr_t
                                        {
                                                  char __size[56l];
                                                  signed long int __align;
                                        };
                                        struct timespec
                                        {
                                                  signed long int tv_sec;
                                                  signed long int tv_nsec;
                                        };
                                        struct stat
                                        {
                                                  unsigned long int st_dev;
                                                  unsigned long int st_ino;
                                                  unsigned long int st_nlink;
                                                  unsigned int st_mode;
                                                  unsigned int st_uid;
                                                  unsigned int st_gid;
                                                  signed int __pad0;
                                                  unsigned long int st_rdev;
                                                  signed long int st_size;
                                                  signed long int st_blksize;
                                                  signed long int st_blocks;
                                                  struct timespec st_atim;
                                                  struct timespec st_mtim;
                                                  struct timespec st_ctim;
                                                  signed long int __glibc_reserved[3l];
                                        };
                                        struct timeval
                                        {
                                                  signed long int tv_sec;
                                                  signed long int tv_usec;
                                        };
                                        struct timezone
                                        {
                                                  signed int tz_minuteswest;
                                                  signed int tz_dsttime;
                                        };
                                        static const char * volatile charset_aliases;
                                        static signed int dummy;
                                        static const signed int fresh_once = (0);
                                        static const signed int fresh_once$link1 = (0);
                                        static const char letters[63l] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0};
                                        static unsigned long int main_thread_after;
                                        static unsigned long int main_thread_before;
                                        static void *mmalloca_results[257l];
                                        struct _IO_FILE *stderr;
                                        static struct hash_node * volatile struniq_hash_table[257l];
                                        static struct hash_node * volatile struniq_hash_table$link1[257l];
                                        static union anonymous$6 struniq_lock = {.__data = {.__lock = 0, .__count = (unsigned int) 0, .__owner = 0, .__nusers = (unsigned int) 0, .__kind = 
                                        0, .__spins = (signed short int) 0, .__elision = 
                                        (signed short int) 0, .__list = {.__prev = (struct __pthread_internal_list *) 0, .__next = (struct __pthread_internal_list *) 0}}};
                                        static union anonymous$6 struniq_lock$link1 = {.__data = {.__lock = 0, .__count = (unsigned int) 0, .__owner = 0, .__nusers = (unsigned int) 0, .__kind = 
                                        0, .__spins = (signed short int) 0, .__elision = 
                                        (signed short int) 0, .__list = {.__prev = (struct __pthread_internal_list *) 0, .__next = (struct __pthread_internal_list *) 0}}};
                                        static volatile signed int work_done;
                                        static unsigned long int worker_thread;
                                        signed int __cs_main_thread(void)
                                        {
IF(0,0,tmain_1)
                                                  static unsigned long int __cs_nondet_main_return_value_pthread_self$1;
                                                  __cs_nondet_main_return_value_pthread_self$1 = __cs_self();
                                                  main_thread_before = __cs_nondet_main_return_value_pthread_self$1;
                                                  static signed int __cs_nondet_main_return_value_pthread_create$5;
                                                  __cs_nondet_main_return_value_pthread_create$5 = __cs_create(&worker_thread, (const union pthread_attr_t *) 0, worker_thread_func_0, 0, 1);
                                                  ;
                                                  ;
                                                  static _Bool __cs_nondet_main___cs_tmp_if_cond_57;
                                                  __cs_nondet_main___cs_tmp_if_cond_57 = __cs_nondet_main_return_value_pthread_create$5 == 0;
                                                  if (__cs_nondet_main___cs_tmp_if_cond_57)
                                                            {
                                                            static void *__cs_nondet_main_ret;
                                                            static unsigned long int __cs_nondet_main_return_value_pthread_self$2;
                                                            __cs_nondet_main_return_value_pthread_self$2 = __cs_self();
tmain_1:
                                                            if (((1 == __cs_pc_cs[0]) & __cs_dataraceDetectionStarted) & (!__cs_dataraceSecondThread))
                                                            {
                                                                      __CPROVER_set_field(&main_thread_after, "dr_write", 1);
                                                            }
IF(0,1,tmain_2)
                                                            if (((1 == __cs_pc[0]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&main_thread_after, "dr_write"))
                                                                      __cs_dataraceNotDetected = 0;
                                                            main_thread_after = __cs_nondet_main_return_value_pthread_self$2;
                                                            ;
                                                            ;
                                                            static _Bool __cs_local_main___cs_dowhile_skipcond_5;
                                                            __cs_local_main___cs_dowhile_skipcond_5 = 1;
                                                            if (!(__cs_local_main___cs_dowhile_skipcond_5 | ((_Bool) 0)))
                                                                                {
                                                                      goto __exit_loop_1;
                                                                      ;
                                                            }
                                                            ;
                                                                                {
                                                                      __cs_local_main___cs_dowhile_skipcond_5 = 0;
                                                                      static signed int __cs_nondet_main_return_value_memcmp$3;
tmain_2:
IF(0,2,tmain_3)
                                                                      __cs_nondet_main_return_value_memcmp$3 = memcmp((const void *) (&main_thread_before), (const void *) (&main_thread_after), sizeof(unsigned long int));
                                                                      ;
                                                                      ;
                                                                      static _Bool __cs_nondet_main___cs_tmp_if_cond_58;
                                                                      __cs_nondet_main___cs_tmp_if_cond_58 = !(__cs_nondet_main_return_value_memcmp$3 == 0);
                                                                      if (__cs_nondet_main___cs_tmp_if_cond_58)
                                                                                                    {
tmain_3:
IF(0,3,tmain_4)
                                                                                if (((3 == __cs_pc[0]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&stderr, "dr_write"))
                                                                                          __cs_dataraceNotDetected = 0;
                                                                                fprintf(stderr, "%s:%d: assertion failed\n", (const void *) "test-thread_create.c", 56);
tmain_4:
IF(0,4,tmain_5)
                                                                                if (((4 == __cs_pc[0]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&stderr, "dr_write"))
                                                                                          __cs_dataraceNotDetected = 0;
                                                                                fflush(stderr);
                                                                                abort();
                                                                      }
                                                                      __CPROVER_assume(__cs_pc_cs[0] >= 5);
                                                                      ;
                                                            }
                                                            ;
tmain_5:
IF(0,5,tmain_6)
                                                            __CPROVER_assume(!(__cs_local_main___cs_dowhile_skipcond_5 | ((_Bool) 0)));
                                                            __exit_loop_1:
                                                            __CPROVER_assume(__cs_pc_cs[0] >= 6);
                                                            ;
                                                            ;
                                                            ;
                                                            ;
                                                            static _Bool __cs_local_main___cs_dowhile_skipcond_6;
                                                            __cs_local_main___cs_dowhile_skipcond_6 = 1;
                                                            if (!(__cs_local_main___cs_dowhile_skipcond_6 | ((_Bool) 0)))
                                                                                {
                                                                      goto __exit_loop_2;
                                                                      ;
                                                            }
                                                            ;
                                                                                {
                                                                      __cs_local_main___cs_dowhile_skipcond_6 = 0;
                                                                      static signed int __cs_nondet_main_return_value_pthread_join$4;
tmain_6:
IF(0,6,tmain_7)
                                                                      if (((6 == __cs_pc[0]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&worker_thread, "dr_write"))
                                                                                __cs_dataraceNotDetected = 0;
                                                                      __cs_nondet_main_return_value_pthread_join$4 = __cs_join(worker_thread, &__cs_nondet_main_ret);
                                                                      ;
                                                                      ;
                                                                      static _Bool __cs_nondet_main___cs_tmp_if_cond_59;
                                                                      __cs_nondet_main___cs_tmp_if_cond_59 = !(__cs_nondet_main_return_value_pthread_join$4 == 0);
                                                                      if (__cs_nondet_main___cs_tmp_if_cond_59)
                                                                                                    {
                                                                                abort();
                                                                      }
                                                                      ;
                                                            }
                                                            ;
tmain_7:
IF(0,7,tmain_8)
                                                            __CPROVER_assume(!(__cs_local_main___cs_dowhile_skipcond_6 | ((_Bool) 0)));
                                                            __exit_loop_2:
                                                            __CPROVER_assume(__cs_pc_cs[0] >= 8);
                                                            ;
                                                            ;
                                                            ;
                                                            ;
                                                            static _Bool __cs_local_main___cs_dowhile_skipcond_7;
                                                            __cs_local_main___cs_dowhile_skipcond_7 = 1;
                                                            if (!(__cs_local_main___cs_dowhile_skipcond_7 | ((_Bool) 0)))
                                                                                {
                                                                      goto __exit_loop_3;
                                                                      ;
                                                            }
                                                            ;
                                                                                {
                                                                      __cs_local_main___cs_dowhile_skipcond_7 = 0;
                                                                      ;
                                                                      ;
                                                                      static _Bool __cs_nondet_main___cs_tmp_if_cond_60;
tmain_8:
IF(0,8,tmain_9)
                                                                      __cs_nondet_main___cs_tmp_if_cond_60 = !(((signed int *) __cs_nondet_main_ret) == (&dummy));
                                                                      if (__cs_nondet_main___cs_tmp_if_cond_60)
                                                                                                    {
tmain_9:
IF(0,9,tmain_10)
                                                                                if (((9 == __cs_pc[0]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&stderr, "dr_write"))
                                                                                          __cs_dataraceNotDetected = 0;
                                                                                fprintf(stderr, "%s:%d: assertion failed\n", (const void *) "test-thread_create.c", 61);
tmain_10:
IF(0,10,tmain_11)
                                                                                if (((10 == __cs_pc[0]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&stderr, "dr_write"))
                                                                                          __cs_dataraceNotDetected = 0;
                                                                                fflush(stderr);
                                                                                abort();
                                                                      }
                                                                      __CPROVER_assume(__cs_pc_cs[0] >= 11);
                                                                      ;
                                                            }
                                                            ;
tmain_11:
IF(0,11,tmain_12)
                                                            __CPROVER_assume(!(__cs_local_main___cs_dowhile_skipcond_7 | ((_Bool) 0)));
                                                            __exit_loop_3:
                                                            __CPROVER_assume(__cs_pc_cs[0] >= 12);
                                                            ;
                                                            ;
                                                            ;
                                                            ;
                                                            static _Bool __cs_local_main___cs_dowhile_skipcond_8;
                                                            __cs_local_main___cs_dowhile_skipcond_8 = 1;
                                                            if (!(__cs_local_main___cs_dowhile_skipcond_8 | ((_Bool) 0)))
                                                                                {
                                                                      goto __exit_loop_4;
                                                                      ;
                                                            }
                                                            ;
                                                                                {
                                                                      __cs_local_main___cs_dowhile_skipcond_8 = 0;
                                                                      ;
                                                                      ;
                                                                      static _Bool __cs_nondet_main___cs_tmp_if_cond_61;
tmain_12:
IF(0,12,tmain_13)
                                                                      if (((12 == __cs_pc[0]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&work_done, "dr_write"))
                                                                                __cs_dataraceNotDetected = 0;
                                                                      __cs_nondet_main___cs_tmp_if_cond_61 = work_done == 0;
                                                                      if (__cs_nondet_main___cs_tmp_if_cond_61)
                                                                                                    {
tmain_13:
IF(0,13,tmain_14)
                                                                                if (((13 == __cs_pc[0]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&stderr, "dr_write"))
                                                                                          __cs_dataraceNotDetected = 0;
                                                                                fprintf(stderr, "%s:%d: assertion failed\n", (const void *) "test-thread_create.c", 64);
tmain_14:
IF(0,14,tmain_15)
                                                                                if (((14 == __cs_pc[0]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&stderr, "dr_write"))
                                                                                          __cs_dataraceNotDetected = 0;
                                                                                fflush(stderr);
                                                                                abort();
                                                                      }
                                                                      __CPROVER_assume(__cs_pc_cs[0] >= 15);
                                                                      ;
                                                            }
                                                            ;
tmain_15:
IF(0,15,tmain_16)
                                                            __CPROVER_assume(!(__cs_local_main___cs_dowhile_skipcond_8 | ((_Bool) 0)));
                                                            __exit_loop_4:
                                                            __CPROVER_assume(__cs_pc_cs[0] >= 16);
                                                            ;
                                                            ;
                                                            goto __exit_main;
                                                            ;
                                                  }
                                                  else
                                                            {
                                                            __CPROVER_assume(__cs_pc_cs[0] >= 16);
tmain_16:
IF(0,16,tmain_17)
                                                            if (((16 == __cs_pc[0]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&stderr, "dr_write"))
                                                                      __cs_dataraceNotDetected = 0;
                                                            fputs("glthread_create failed\n", stderr);
                                                            goto __exit_main;
                                                            ;
                                                  }
                                                  __CPROVER_assume(__cs_pc_cs[0] >= 17);
                                                  ;
                                                  __exit_main:
                                                  __CPROVER_assume(__cs_pc_cs[0] >= 17);
                                                  ;
                                                  ;
tmain_17: 
                                                  __cs_exit(0, 0);
                                        }
                                        void *worker_thread_func_0(void *__cs_param_worker_thread_func_arg)
                                        {
                                                  if (((0 == __cs_pc_cs[1]) & __cs_dataraceDetectionStarted) & (!__cs_dataraceSecondThread))
                                                  {
                                                            __CPROVER_set_field(&work_done, "dr_write", 1);
                                                  }
IF(1,0,tworker_thread_func_0_1)
                                                  if (((0 == __cs_pc[1]) & __cs_dataraceSecondThread) & __CPROVER_get_field(&work_done, "dr_write"))
                                                            __cs_dataraceNotDetected = 0;
                                                  work_done = 1;
                                                  goto __exit_worker_thread_func;
                                                  ;
                                                  __exit_worker_thread_func:
                                                  __CPROVER_assume(__cs_pc_cs[1] >= 1);
                                                  ;
                                                  ;
tworker_thread_func_0_1: 
                                                  __cs_exit((void *) (&dummy), 1);
                                        }
                                        int main(void)
                                        {
                                                  __CPROVER_field_decl_global("dr_write", (_Bool) 0);
                                                  unsigned __CPROVER_bitvector[1] __cs_dr_ts;
                                                  __CPROVER_assume(__cs_dr_ts <= 1);
/* round  0 */
/* main */
                                                  unsigned __CPROVER_bitvector[5] __cs_tmp_t0_r0;
                                                  __cs_pc_cs[0] = __cs_tmp_t0_r0;
                                                  __CPROVER_assume(__cs_pc_cs[0] > 0);
                                                  __CPROVER_assume(__cs_pc_cs[0] <= 17);
                                                  if (__cs_dr_ts == 0)
                                                            __cs_dataraceDetectionStarted = 1;
                                                  __cs_main_thread();
                                                  if (__cs_dataraceDetectionStarted)
                                                            __cs_dataraceSecondThread = 1;
                                                  __cs_pc[0] = __cs_pc_cs[0];
/* worker_thread_func_0 */
                                                  unsigned __CPROVER_bitvector[1] __cs_tmp_t1_r0;
                                                  if (__cs_dataraceContinue & __cs_active_thread[1])
                                                  {
                                                            __cs_pc_cs[1] = __cs_tmp_t1_r0;
                                                            __CPROVER_assume(__cs_pc_cs[1] <= 1);
                                                            if (__cs_dr_ts == 1)
                                                                      __cs_dataraceDetectionStarted = 1;
                                                            worker_thread_func_0(__cs_threadargs[1]);
                                                            if (__cs_dataraceSecondThread & (__cs_tmp_t1_r0 > __cs_pc[1]))
                                                                      __cs_dataraceContinue = 0;
                                                            if (__cs_dataraceDetectionStarted)
                                                                      __cs_dataraceSecondThread = 1;
                                                            __cs_pc[1] = __cs_pc_cs[1];
                                                  }
                                                  unsigned __CPROVER_bitvector[5] __cs_tmp_t0_r1;
                                                  if (((__cs_dr_ts > (-2)) & __cs_dataraceContinue) & __cs_active_thread[0])
                                                  {
                                                            __cs_pc_cs[0] = __cs_pc[0] + __cs_tmp_t0_r1;
                                                            __CPROVER_assume(__cs_pc_cs[0] >= __cs_pc[0]);
                                                            __CPROVER_assume(__cs_pc_cs[0] <= 17);
                                                            __cs_main_thread();
                                                  }
                                                  __CPROVER_assert(__cs_dataraceNotDetected, "Data race failure");
                                                  return 0;
                                        }
                                        
